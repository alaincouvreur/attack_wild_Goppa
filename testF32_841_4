load "KeyGen.mgm";
load "BreakKey.mgm";
load "CompCmi.mgm";
q:=32;
r:=4;
a:=q^2-841;

C, L, g:=KeyGen(q,r,a,2);

print "\n\n************************************";
printf "\nGoppa polynomial:\ng=%o\n\n", g;

n:=Length(C);
printf "Code of length %o.\n",n;
printf "Code of dimension %o.\n",Dimension(C);


F:=GF(q);
FF<w>:=ext<F|2>;

printf "Computing the gap sequence....";
GS:=GapSeq(F,FF, r, n, q+1);
print " [OK]";
print GS;

print "***********************************";
print "Computation of the filtrations:\n\n";
print "***********************************";

A0:=MultiCompCi (C, 1, 23, 1000);
A1:=MultiCompCi (C, 2, 23, 1000);

C0m11:=ComputeCmi(C, A0[1] meet Dual(&+A0[2][1..11]), C, C, 1, 1000);
C1m11:=ComputeCmi(C, A1[1] meet Dual(&+A1[2][1..11]), C, C, 2, 1000);

C0m11:=UnShorten(C0m11, {1});
C1m11:=UnShorten(C1m11, {2});

printf "Dimension of C0_{-11} = %o.\n", Dimension(C0m11);
printf "Dimension of C1_{-11} = %o.\n", Dimension(C1m11);

C0:=A0[3];
C1:=A1[3];


print "Tests on the C_i(23)";
print Dimension(C0) eq GS[23][2];
print Dimension(C1) eq GS[23][2];


print "Computation of the filtrations Done!\n";
print "************************************\n";

		 F:=BaseRing(C);
		 FF<w>:=ext<F | 2>;
		 n:=Length(C);


print "Computation of the norms and association by pairs";

R0:=CompXi(C0m11, C0, 1);
R1:=CompXi(C1m11, C1, 2);


R0:=[ElementToSequence(r) : r in R0];
R1:=[ElementToSequence(r) : r in R1];

a0:=#R0;

print "\n";
printf "We found %o candidates for the norms of the supports.\n", #R0;
print "\n";

assert #R0 eq #R1;
t:=0;
jj:=1;

while #R0 gt 0 and t eq 0 do
	u0:=R0[1];
	u1:=ByPairs(R0,R1, 1);
	Exclude(~R0, u0);
	Exclude(~R1, u1);
	print "\n";

   	d:=q^2 - r*(q+1);
	printf "Try with candidate pair number: %o.\n", jj;
	print "\n";
	print "Computation of the minimal polynomials.\n";
	print "\n";
	
	P:=MiniPols(u0, u1);

	print "Done! \n \n";
	print "Re-organizing the support.\n \n";

	U:=SuppReorg(P, F, FF);

	//-----------------------------------------------
	fi:=U[4];
	fj:=U[5];
	s:=U[3];
	Cp:=C^s;

	printf "For this candidat, there are %o elements of the support in Fq,\n", fi;
	printf "and %o elements of the support in F_{q^2} whose conjugate is not in the support.\n \n", fj;

	if fj eq 0 then Cpe:=Cp;
	   else Cpe:=UnShorten(Cp, {n-fj+2..n+fj by 2});
	end if;

	A:=U[1];
	Ahard:=U[2];

	M:=[l : l in FF];
	M:=Ahard cat [l : l in M | l notin Ahard];

	R<x>:=PolynomialRing(FF);	 
   	X:=[x^i : i in {0..d-1}];
	G:=Matrix(d, q^2, [[Evaluate(a, b) : b in M] : a in X]);
	RS:=LinearCode(G);
	SRS:=SubfieldSubcode(RS, F);		  
	SRS := ShortenCode(SRS, {#Ahard+1..q^2});
	delete RS, G;


	print Dimension(Cp);
	print Dimension(Cpe);
	print Dimension(SRS);

	T:=EquivComp(Cpe, SRS, fi, fj);
    a:=Dimension(T);

	printf "The space of morphisms from our code to the SRS has dimension: %o.\n \n", a;

	if a gt 10 then 
	   print "This candidate has a too large space of morphisms, we lave it aside.\n \n";
	   t:=0;
	   elif a gt 0 then		 
	   V:=EquivComp2(T, fi, fj);
	   t:=#V;
	end if;

	jj+:=1;
end while;

if t eq 0 then
   print "Pair not found";
else 
    print "We found a candidate pair to construct a GRS";
    Coeffts:=V[1];
	M:=EquivMatrice(Coeffts, fi ,fj);
	assert LinearCode(BasisMatrix(Cpe) * M) subset SRS;
	N:=SuppAndWeightComp(M,Ahard, fi,fj);
		
	// Compute the GRS code.
	W0:=CompGRS(N[1]);
	W1:=[W0[i]*N[2][i] : i in {1..#N[2]}];
	S:=PermuteSeq(N[1],s^(-1));
	W:=PermuteSeq(W1,s^(-1));

	GRS:=GRSCode(S,W, n - r*(q+1));
	print "Comparision with the original public key.\n \n";
	if SubfieldSubcode(GRS,F) eq C then
	    print "[SUCCESS]";
	else
		print "[ATTACK FAILED]";
	end if;
end if;